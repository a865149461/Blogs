---
title: 动态规划提高课05--区间DP
date: 2020-06-05 18:58:31
categories:
	- 数据结构与算法
tags:
	- 动态规划
mathjax: true 
---

## 区间DP

1. 环形问题：破链成环，复制区间
2. 



#### 环形石子合并

[原题链接](https://www.acwing.com/problem/content/1070/)

#### 解题思路

最后一步操作肯定是把两堆石子合并，而这两堆肯定是对应原来的环形的两边互不相交的部分。所以相当于枚举环的断点，然后求数组的石子合并问题。这样的时间复杂度为`O(n^4)`

考虑破链成环。将原数组复制一份。那么在长度为`2 * n` 的区间上做区间DP，然后枚举所有的长度为`n`的情况，取最小和最大即可。

时间复杂度`O(n^3)`

- 如果石子可以随便移，那就是哈弗曼编码问题
- 如果不是环形，则直接区间DP即可

#### C++代码

```c++
#include<iostream>
using namespace std;

const int N  = 210;
int q[N * 2];
int dp[N * 2][N * 2], dp2[N * 2][N * 2];
int s[N * 2];

int main(){
    
    int n;
    cin >> n;
    for(int i = 1; i <= n; i ++) cin >> q[i];
    for(int i = n + 1; i <= 2 * n; i ++) q[i] = q[i - n];  // 复制数组
    for(int i = 1; i <= 2 * n; i ++) s[i] = s[i - 1] + q[i];   // 预处理前缀和
    for(int step = 2; step <= n; step ++){   // 枚举区间长度
        for(int i = 0; i + step - 1 <= 2 * n; i ++){  // 枚举区间起点
            dp[i][i + step - 1] = 0x3f3f3f3f;
            dp2[i][i + step -1] = 0;
            for(int j = i; j < i + step - 1; j ++){  // 枚举断点，更新状态
                dp[i][i + step - 1] = min(dp[i][i + step - 1], dp[i][j] + dp[j + 1][i + step - 1] + s[i + step - 1] - s[i - 1]);
                dp2[i][i + step - 1] = max(dp2[i][i + step - 1], dp2[i][j] + dp2[j + 1][i + step - 1] + s[i + step - 1] - s[i - 1]);
            }
        }
    }
    int mi = 0x3f3f3f3f, ma = 0;
    for(int i = 1; i <= n; i ++) {  // 枚举所有长度为n的区间，找到最大和最小即可
        mi = min(mi, dp[i][i + n - 1]);
        ma = max(ma, dp2[i][i + n - 1]);
    }
    cout << mi << endl << ma << endl;
}
```

### 能量项链

[原题链接](https://www.acwing.com/problem/content/322/)

#### 解题思路

石子合并的变种，只不过是状态转移发生了变化。求一个状态的时候，枚举最后一步的分界点即可。

#### C++代码

```c++
#include<iostream>
using namespace std;

const int N = 110;
int q[2 * N];
int dp[2 * N][2 * N];

int main(){
    
    int n;
    cin >> n;
    for(int i = 1; i <= n; i ++) cin >> q[i];
    for(int i = n + 1; i <= 2 * n; i ++) q[i] = q[i - n];  // 复制
    for(int step = 3; step <= n + 1; step ++){  // 枚举区间长度
        for(int i = 1; i + step - 1 <= n * 2; i ++){  // 枚举区间起点
            dp[i][i + step - 1] = 0;
            for(int k = i + 1; k  <  i + step - 1; k ++){  // 枚举最后一步合并的分界点
                dp[i][i + step - 1] = max(dp[i][i + step - 1], dp[i][k] + dp[k][i + step - 1] + q[i] * q[k] * q[i + step - 1]);
            }
        }
    }
    int ans = 0;
    for(int i = 1; i <= n; i ++){  // 找到长度为n + 1的区间的答案的最大值
        ans = max(ans, dp[i][i + n]);
    }
    cout << ans;
    return 0;
}
```

