---
title: 动态规划杂题2
date: 2020-06-02 00:10:57
categories:
	- 数据结构与算法
tags:
	- 动态规划
	- 杂题汇总

mathjax: true
---

### 每个人戴不同帽子的方案数

[原题链接](https://leetcode-cn.com/problems/number-of-ways-to-wear-different-hats-to-each-other/)

#### 解题思路

状态压缩DP(集合类)

定义状态**`dp[i][j]`** 为从**`1 - i`**将**`1 - i`**顶帽子，分给状态为**`j`**的方法。则分为两类：

- 不使用第**`i`**顶帽子，则为**`dp[i-1][j]`**

* 使用第**`i`**顶帽子，则枚举状态**`j`**中的人，并且这个人也喜欢这个帽子，有**`dp[i-1][j - (1 << k)]`**, 第k个人待第**`i`**顶帽子的方法

最终输出**`dp[40][(1 << n) - 1]`**

时间复杂度$40 \times 2 ^n \times n$

空间复杂度$40 \times 2 ^ n$

#### C++代码

```c++
class Solution {
public:
    
    int dp[41][1 << 10] = {0};
    bool has[10][41] = {false};
    const int mod = 1e9+7;
    
    int numberWays(vector<vector<int>>& hats) {
        int n = hats.size();
        for(int i = 0; i < n; i ++){  // 预处理好第i个人是否喜欢第j顶帽子，用于后面转移判断使用
            for(auto j : hats[i]){
                has[i][j] = true;
            }
        }
        dp[0][0] = 1;
        for(int i = 1; i <= 40; i ++){
            for(int j = 0; j < 1 << n; j ++){
                dp[i][j] += dp[i-1][j];  // 不选第i顶帽子
                dp[i][j] %= mod;
                for(int k = 0; k < n; k ++){   // 选第i顶帽子
                    if((j & (1 << k)) && has[k][i]){  // 枚举所有人，并判断这个人是不是喜欢第i顶帽子
                        dp[i][j] += dp[i-1][j - (1 << k)]; // 状态转移
                        dp[i][j] %= mod;
                    }
                }
            }
        }
        return dp[40][(1 << n) - 1];
    }
};
```

### 新21点

[原题链接](https://leetcode-cn.com/problems/new-21-game/)

#### 解题思路

动态规划。 定义状态**`dp[i]`**为处在**`i`**位置时(现在有了`i`分)，满足题意的概率是多少。

当处于**`i`**时，下一步有**`W`**种情况。由全概率公式有

$$P(X) = \sum_{Y}P(X|Y)$$

所以有$dp[i] = \frac{\sum_{j = 1}^{W} dp[i + j]}{W}$

可以看到，每个状态的计算，依赖其后面的**`W`**个状态。 在更新的时候，可以用一个量记录窗口为**`W`**的区间的结果和。

然后滑动的时候不断删除尾元素，加入头元素即可。

边界情况：

**-** 当**`i`**处于**`K`**到**`N`**之间时，已经满足，概率为**`1`**

**-** 当**`i`**大于**`N`**时，概率为**`0`**

然后从**`k-1`**开始进行状态计算，最后输出**`dp[0]`**

时间复杂度**`O(N)`**

#### C++代码

```c++
class Solution {
public:
    double new21Game(int N, int K, int W) {
        vector<double> dp(N + W + 1, 0);
        for(int i = K; i <= N; i ++) dp[i] = 1;
        double t = 0;
        for(int i = K; i <= K + W - 1; i ++) t += dp[i];
        for(int i = K - 1; i >= 0; i --){
            dp[i] = t / W;
            t -= dp[i + W];
            t += dp[i];
        }
        return dp[0];
    }
};
```

